#!/bin/bash
# Ralph Wiggum 2.0 - GitHub-Native AI Agent Loop
# Named after the Simpsons character who never stops trying
#
# Usage:
#   ralph <issue-url|number> [max-iterations]  Run the autonomous loop
#   ralph --new [feature-name]                 Interactive spec authoring (creates GitHub issues)
#   ralph --status                             Show status of all ralph specs in current repo
#
# Environment variables:
#   RALPH_AGENT_CMD - Command to invoke the agent (default: copilot)

set -e

# ═══════════════════════════════════════════════════════════════════════════
# Configuration
# ═══════════════════════════════════════════════════════════════════════════

AGENT_CMD="${RALPH_AGENT_CMD:-copilot --yolo --model claude-opus-4.5}"
RALPH_LABEL="ralph-spec"
RALPH_STORY_LABEL="ralph-story"
RALPH_CHECKPOINT_LABEL="ralph-checkpoint"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

# ═══════════════════════════════════════════════════════════════════════════
# Helper functions
# ═══════════════════════════════════════════════════════════════════════════

print_header() {
  echo ""
  echo -e "${BLUE}═══════════════════════════════════════════════════════${NC}"
  echo -e "${BLUE}  $1${NC}"
  echo -e "${BLUE}═══════════════════════════════════════════════════════${NC}"
}

print_status() {
  echo -e "${GREEN}[ralph]${NC} $1"
}

print_warning() {
  echo -e "${YELLOW}[ralph]${NC} $1"
}

print_error() {
  echo -e "${RED}[ralph]${NC} $1"
}

usage() {
  echo "Ralph Wiggum 2.0 - GitHub-Native AI Agent Loop"
  echo ""
  echo "Usage:"
  echo "  ralph <issue-url|number> [max-iterations]  Run the autonomous loop"
  echo "  ralph --new [feature-name]                 Interactive spec authoring"
  echo "  ralph --status                             Show status of all specs"
  echo ""
  echo "Arguments:"
  echo "  issue-url|number  GitHub issue URL or number (parent spec issue)"
  echo "  max-iterations    Maximum loop iterations (default: 100)"
  echo "  feature-name      Name for the new feature (optional)"
  echo ""
  echo "Environment variables:"
  echo "  RALPH_AGENT_CMD   Agent command (default: copilot)"
  echo ""
  echo "Labels used:"
  echo "  $RALPH_LABEL          Parent spec issues"
  echo "  $RALPH_STORY_LABEL        Story sub-issues"
  echo "  $RALPH_CHECKPOINT_LABEL   E2E checkpoint sub-issues"
  exit 1
}

# ═══════════════════════════════════════════════════════════════════════════
# GitHub utility functions
# ═══════════════════════════════════════════════════════════════════════════

# Get the current repo in owner/repo format
gh_get_repo() {
  gh repo view --json nameWithOwner --jq '.nameWithOwner'
}

# Create an issue and return its number
# Usage: gh_create_issue "title" "body" "label1,label2"
# Returns: issue number
gh_create_issue() {
  local title="$1"
  local body="$2"
  local labels="$3"

  local url
  if [ -n "$labels" ]; then
    url=$(gh issue create --title "$title" --body "$body" --label "$labels")
  else
    url=$(gh issue create --title "$title" --body "$body")
  fi

  # Extract issue number from URL (e.g., https://github.com/owner/repo/issues/42 -> 42)
  echo "$url" | grep -oP '/issues/\K[0-9]+'
}

# Get node ID from issue number
# Usage: gh_get_issue_id 42
gh_get_issue_id() {
  local number="$1"
  gh issue view "$number" --json id --jq '.id'
}

# Get issue number from URL or return as-is if already a number
# Usage: gh_parse_issue_ref "https://github.com/owner/repo/issues/42" -> 42
gh_parse_issue_ref() {
  local ref="$1"
  if [[ $ref =~ ^[0-9]+$ ]]; then
    echo "$ref"
  elif [[ $ref =~ /issues/([0-9]+) ]]; then
    echo "${BASH_REMATCH[1]}"
  else
    print_error "Invalid issue reference: $ref"
    exit 1
  fi
}

# Link child as sub-issue of parent
# Usage: gh_link_sub_issue "parent_node_id" "child_node_id"
gh_link_sub_issue() {
  local parent_id="$1"
  local child_id="$2"

  gh api graphql -f query='
    mutation($parent: ID!, $child: ID!) {
      addSubIssue(input: {issueId: $parent, subIssueId: $child}) {
        subIssue { id }
      }
    }
  ' -f parent="$parent_id" -f child="$child_id" --silent
}

# Get sub-issues of a parent issue
# Usage: gh_get_sub_issues "parent_node_id"
# Returns JSON array: [{id, number, title, state}, ...]
gh_get_sub_issues() {
  local parent_id="$1"

  gh api graphql -f query='
    query($id: ID!) {
      node(id: $id) {
        ... on Issue {
          subIssues(first: 100) {
            nodes {
              id
              number
              title
              state
              labels(first: 10) {
                nodes { name }
              }
            }
          }
        }
      }
    }
  ' -f id="$parent_id" --jq '.data.node.subIssues.nodes'
}

# Get issue details
# Usage: gh_get_issue 42
gh_get_issue() {
  local number="$1"
  gh issue view "$number" --json id,number,title,body,state,labels
}

# Close an issue with a comment
# Usage: gh_close_issue 42 "Completed: description of what was done"
gh_close_issue() {
  local number="$1"
  local comment="$2"

  if [ -n "$comment" ]; then
    gh issue comment "$number" --body "$comment"
  fi
  gh issue close "$number"
}

# Add a comment to an issue
# Usage: gh_add_comment 42 "Progress update..."
gh_add_comment() {
  local number="$1"
  local body="$2"

  gh issue comment "$number" --body "$body"
}

# Get recent comments from an issue
# Usage: gh_get_comments 42 [limit]
gh_get_comments() {
  local number="$1"
  local limit="${2:-5}"

  gh issue view "$number" --json comments --jq ".comments | .[-${limit}:]"
}

# Check if labels exist, create if not
gh_ensure_labels() {
  local labels
  labels=$(gh label list --json name --jq '.[].name')

  # Check and create ralph-spec label
  if ! echo "$labels" | grep -q "^${RALPH_LABEL}$"; then
    gh label create "$RALPH_LABEL" --description "Ralph spec (parent issue)" --color "5319E7" 2>/dev/null || true
  fi

  # Check and create ralph-story label
  if ! echo "$labels" | grep -q "^${RALPH_STORY_LABEL}$"; then
    gh label create "$RALPH_STORY_LABEL" --description "Ralph story (sub-issue)" --color "0E8A16" 2>/dev/null || true
  fi

  # Check and create ralph-checkpoint label
  if ! echo "$labels" | grep -q "^${RALPH_CHECKPOINT_LABEL}$"; then
    gh label create "$RALPH_CHECKPOINT_LABEL" --description "Ralph E2E checkpoint" --color "D93F0B" 2>/dev/null || true
  fi

  # Check and create ralph-running label (for locking)
  if ! echo "$labels" | grep -q "^ralph-running$"; then
    gh label create "ralph-running" --description "Ralph is currently running on this spec" --color "FBCA04" 2>/dev/null || true
  fi
}

# ═══════════════════════════════════════════════════════════════════════════
# Status command
# ═══════════════════════════════════════════════════════════════════════════

show_status() {
  print_header "Ralph Status"

  local repo
  repo=$(gh_get_repo 2>/dev/null) || {
    print_error "Not in a git repository or gh CLI not authenticated"
    exit 1
  }

  print_status "Repository: $repo"
  echo ""

  # Get all issues with ralph-spec label
  local specs
  specs=$(gh issue list --label "$RALPH_LABEL" --state all --json number,title,state --jq '.[]' 2>/dev/null)

  if [ -z "$specs" ]; then
    echo "No ralph specs found in this repository."
    echo "Create one with: ralph --new"
    exit 0
  fi

  # Process each spec
  gh issue list --label "$RALPH_LABEL" --state all --json number,title,state | jq -c '.[]' | while read -r spec; do
    local number title state
    number=$(echo "$spec" | jq -r '.number')
    title=$(echo "$spec" | jq -r '.title')
    state=$(echo "$spec" | jq -r '.state')

    # Get parent node ID
    local parent_id
    parent_id=$(gh_get_issue_id "$number")

    # Get sub-issues
    local sub_issues
    sub_issues=$(gh_get_sub_issues "$parent_id")

    local total done
    total=$(echo "$sub_issues" | jq 'length')
    done=$(echo "$sub_issues" | jq '[.[] | select(.state == "CLOSED")] | length')

    # Format state
    local state_display
    if [ "$state" = "OPEN" ]; then
      if [ "$done" -eq "$total" ] && [ "$total" -gt 0 ]; then
        state_display="${GREEN}READY TO CLOSE${NC}"
      else
        state_display="${CYAN}IN PROGRESS${NC}"
      fi
    else
      state_display="${GREEN}COMPLETED${NC}"
    fi

    echo -e "${BOLD}#$number: $title${NC} [$state_display]"
    echo -e "  Progress: ${GREEN}$done${NC}/${total} stories complete"

    # Show remaining stories
    if [ "$done" -lt "$total" ]; then
      echo "  Remaining:"
      echo "$sub_issues" | jq -r '.[] | select(.state == "OPEN") | "    - #\(.number): \(.title)"'
    fi
    echo ""
  done

  exit 0
}

# ═══════════════════════════════════════════════════════════════════════════
# New spec command (interactive) - Creates GitHub Issues
# ═══════════════════════════════════════════════════════════════════════════

new_spec() {
  local feature_name="${1:-}"

  print_header "New Spec - Interactive Mode (GitHub Issues)"

  # Ensure we're in a repo and labels exist
  local repo
  repo=$(gh_get_repo 2>/dev/null) || {
    print_error "Not in a git repository or gh CLI not authenticated"
    exit 1
  }

  print_status "Repository: $repo"
  gh_ensure_labels

  if [ -n "$feature_name" ]; then
    print_status "Feature name: $feature_name"
  else
    print_status "The agent will help you name the feature."
  fi

  echo ""

  # Generate the spec authoring prompt
  read -r -d '' PROMPT <<'PROMPT_END' || true
You are a product manager helping to create a feature specification. Your job is to interview the user, understand what they want to build, and create GitHub issues for the spec.

# Your Task

1. Ask what feature or change they want to build (if not already clear)
2. Ask 3-5 essential clarifying questions to understand:
   - **Problem/Goal:** What problem does this solve? Why build it?
   - **Core Functionality:** What are the key user actions?
   - **Scope/Boundaries:** What should it NOT do?
   - **Success Criteria:** How do we know it's done?

3. Format questions with lettered options for quick responses:
   ```
   1. What is the primary goal?
      A. Improve user experience
      B. Add new capability
      C. Fix existing pain point
      D. Other: [please specify]
   ```
   This lets users respond with "1A, 2C, 3B" quickly.

4. After gathering answers, create the GitHub issues.

# Creating the Issues

You will create:
1. **One parent issue** (the spec) with label `ralph-spec`
2. **Multiple child issues** (the stories) with label `ralph-story` or `ralph-checkpoint`

## Parent Issue Format

Title: `[Feature Name]`

Body:
```markdown
## Overview
Brief description of the feature and the problem it solves.

## Branch
`ralph/[feature-name-kebab-case]`

## Goals
- Specific, measurable objectives
- What success looks like

## Non-Goals
What this feature will NOT include.

## Stories
<!-- Sub-issues will be linked automatically -->
```

## Story Issue Format

Title: `US-XXX: [Short descriptive title]`

Body:
```markdown
## Description
As a [user], I want [feature] so that [benefit].

## Acceptance Criteria
- [ ] Specific, verifiable criterion
- [ ] Another criterion
- [ ] Typecheck passes
- [ ] [For UI changes] Verify in browser

## Notes
Any additional context for implementation.
```

## Checkpoint Issue Format (for E2E validation)

Title: `CHECKPOINT: [What to verify]`
Label: `ralph-checkpoint` (in addition to `ralph-story`)

Body:
```markdown
## Description
Verify that the implemented stories work together end-to-end.

## Verification Steps
- [ ] Step 1: Navigate to X
- [ ] Step 2: Perform action Y
- [ ] Step 3: Verify result Z

## If Issues Found
Create new story issues to fix problems, then re-run this checkpoint.
```

# Story Sizing Rules

Each story must be completable in ONE iteration (one context window).

**Right-sized stories:**
- Add a database column and migration
- Add a UI component to an existing page
- Add an API endpoint with basic logic

**Too big (split these):**
- "Build the entire dashboard" → Split into: schema, queries, components
- "Add authentication" → Split into: schema, middleware, login UI, sessions

# Story Ordering & Checkpoints

Order stories by dependency AND add checkpoints at integration points:

1. Schema/database changes
2. Backend/server logic
3. **CHECKPOINT: Verify backend works** (after backend stories)
4. UI components
5. **CHECKPOINT: Verify full flow E2E** (after UI stories)
6. **E2E-FINAL: Complete feature validation** (always last)

# Creating Issues with gh CLI

Use these commands to create the issues:

```bash
# Create parent issue
gh issue create --title "Feature Name" --body "..." --label "ralph-spec"

# Create story issues (note the number returned)
gh issue create --title "US-001: Story title" --body "..." --label "ralph-story"

# Create checkpoint issues
gh issue create --title "CHECKPOINT: Verify X" --body "..." --label "ralph-story,ralph-checkpoint"
```

After creating all issues, link them as sub-issues using the GraphQL API:

```bash
# Get node IDs
PARENT_ID=$(gh issue view PARENT_NUMBER --json id --jq '.id')
CHILD_ID=$(gh issue view CHILD_NUMBER --json id --jq '.id')

# Link as sub-issue
gh api graphql -f query='
  mutation($parent: ID!, $child: ID!) {
    addSubIssue(input: {issueId: $parent, subIssueId: $child}) {
      subIssue { id }
    }
  }
' -f parent="$PARENT_ID" -f child="$CHILD_ID"
```

# Important

- Do NOT implement anything - just create the issues
- Ask questions FIRST, then create the issues
- Keep stories small and focused
- Always include checkpoints at integration points
- Always end with E2E-FINAL checkpoint
- Link ALL story issues as sub-issues of the parent
PROMPT_END

  # Add feature name hint if provided
  if [ -n "$feature_name" ]; then
    PROMPT="$PROMPT

The user wants to build a feature called: $feature_name"
  fi

  # Run the agent interactively
  $AGENT_CMD -i "$PROMPT"

  exit 0
}

# ═══════════════════════════════════════════════════════════════════════════
# Argument parsing
# ═══════════════════════════════════════════════════════════════════════════

if [ -z "$1" ] || [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
  usage
fi

if [ "$1" = "--status" ]; then
  show_status
fi

if [ "$1" = "--new" ]; then
  new_spec "$2"
fi

# ═══════════════════════════════════════════════════════════════════════════
# Main loop mode - expect an issue reference
# ═══════════════════════════════════════════════════════════════════════════

ISSUE_REF="$1"
MAX_ITERATIONS=${2:-100}

# Parse issue reference
PARENT_NUMBER=$(gh_parse_issue_ref "$ISSUE_REF")

# Verify we're in a repo
REPO=$(gh_get_repo 2>/dev/null) || {
  print_error "Not in a git repository or gh CLI not authenticated"
  exit 1
}

# Ensure labels exist
gh_ensure_labels

# Verify the issue exists and has the right label
PARENT_ISSUE=$(gh_get_issue "$PARENT_NUMBER" 2>/dev/null) || {
  print_error "Issue #$PARENT_NUMBER not found"
  exit 1
}

PARENT_LABELS=$(echo "$PARENT_ISSUE" | jq -r '.labels[].name' | tr '\n' ',')
if [[ ! $PARENT_LABELS =~ $RALPH_LABEL ]]; then
  print_warning "Issue #$PARENT_NUMBER doesn't have the '$RALPH_LABEL' label"
  print_warning "Adding label..."
  gh issue edit "$PARENT_NUMBER" --add-label "$RALPH_LABEL"
fi

PARENT_TITLE=$(echo "$PARENT_ISSUE" | jq -r '.title')
PARENT_BODY=$(echo "$PARENT_ISSUE" | jq -r '.body')
PARENT_ID=$(echo "$PARENT_ISSUE" | jq -r '.id')

# Extract branch name from issue body (looks for "Branch: `ralph/...`" or "## Branch\n`ralph/...`")
BRANCH_NAME=$(echo "$PARENT_BODY" | grep -oP '(?<=Branch[:\s]*`)[^`]+' | head -1 || echo "")
if [ -z "$BRANCH_NAME" ]; then
  # Generate from title
  BRANCH_NAME="ralph/$(echo "$PARENT_TITLE" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-//' | sed 's/-$//')"
fi

# ═══════════════════════════════════════════════════════════════════════════
# Lock mechanism (using issue labels to prevent concurrent runs)
# ═══════════════════════════════════════════════════════════════════════════

LOCK_LABEL="ralph-running"

# Check if already running
if echo "$PARENT_LABELS" | grep -q "$LOCK_LABEL"; then
  print_error "Another ralph instance appears to be running on this spec"
  print_error "If this is stale, remove the '$LOCK_LABEL' label from issue #$PARENT_NUMBER"
  exit 1
fi

# Add lock label
gh issue edit "$PARENT_NUMBER" --add-label "$LOCK_LABEL" 2>/dev/null || true

# Cleanup function to remove lock
cleanup() {
  gh issue edit "$PARENT_NUMBER" --remove-label "$LOCK_LABEL" 2>/dev/null || true
}
trap cleanup EXIT

# ═══════════════════════════════════════════════════════════════════════════
# Generate iteration prompt with context
# ═══════════════════════════════════════════════════════════════════════════

generate_prompt() {
  local story_number="$1"
  local story_title="$2"
  local story_body="$3"
  local is_checkpoint="$4"
  local recent_comments="$5"
  local git_diff_stat="$6"
  local completed_stories="$7"

  if [ "$is_checkpoint" = "true" ]; then
    cat <<PROMPT_END
You are an autonomous coding agent performing E2E validation on a software project.

# Context

**Feature:** $PARENT_TITLE
**Branch:** $BRANCH_NAME
**Repository:** $REPO

## Completed Stories
$completed_stories

## Git Changes in This Branch
\`\`\`
$git_diff_stat
\`\`\`

## Recent Progress
$recent_comments

# Your Task: E2E CHECKPOINT

**Issue:** #$story_number - $story_title

$story_body

## Instructions

1. Ensure you're on branch \`$BRANCH_NAME\`
2. Detect project type and set up E2E tooling (see below)
3. Run the application and verify the flow
4. Document what works and what doesn't

## E2E Tooling Setup

### Step 1: Detect Package Manager

Check which lockfile exists and use the corresponding runner:
- \`bun.lockb\` → use \`bunx\`
- \`pnpm-lock.yaml\` → use \`pnpm dlx\`
- \`yarn.lock\` → use \`yarn dlx\`
- \`package-lock.json\` or none → use \`npx\`

### Step 2: Ensure Playwright is Available

For web apps (Next.js, React, Vue, etc.):
\`\`\`bash
# Check if playwright is available, install if not
if ! command -v playwright &> /dev/null && ! [runner] playwright --version &> /dev/null; then
  [runner] playwright install chromium
fi
\`\`\`

Replace \`[runner]\` with the detected runner (bunx, npx, etc.).

### Step 3: Run E2E Verification

**File locations:**
- E2E scripts go in the repo: \`e2e/\` directory (create if needed)
- Screenshots go to: \`~/.ralph/screenshots/$REPO/$story_number/\`

Write a Playwright test in the repo:
\`\`\`typescript
// e2e/checkpoint-$story_number.spec.ts
import { test, expect } from '@playwright/test';

test('$story_title', async ({ page }) => {
  // Navigate to the app
  await page.goto('http://localhost:3000');

  // Perform verification steps from the checkpoint criteria
  // Use assertions to verify behavior
  await expect(page.locator('...')).toBeVisible();

  // Save screenshot for reference (outside repo)
  await page.screenshot({
    path: \`\${process.env.HOME}/.ralph/screenshots/$REPO/$story_number/checkpoint.png\`,
    fullPage: true
  });
});
\`\`\`

Run with: \`[runner] playwright test e2e/checkpoint-$story_number.spec.ts\`

**Commit the test file** - it becomes a regression test:
\`\`\`bash
git add e2e/
git commit -m "test: add e2e test for #$story_number"
\`\`\`

### For React Native / Expo

Detect which approach to use:

**A. If web-compatible (no native modules or using Expo Go):**
1. Use Expo's web export: \`[runner] expo start --web\`
2. Run Playwright against http://localhost:8081

**B. If using custom dev client (native modules):**

Use **Maestro** for native E2E testing:
\`\`\`bash
# Install Maestro if not available
if ! command -v maestro &> /dev/null; then
  curl -Ls "https://get.maestro.mobile.dev" | bash
  export PATH="\$PATH:\$HOME/.maestro/bin"
fi

# Start the app on simulator (iOS example)
[runner] expo run:ios --device "iPhone 15"

# Or for Android
[runner] expo run:android
\`\`\`

Write a Maestro flow file in the repo:
\`\`\`yaml
# e2e/checkpoint-$story_number.yaml
appId: com.yourapp.id  # from app.json
---
- launchApp
- assertVisible: "Expected Text"
- tapOn: "Button Text"
- takeScreenshot: ~/.ralph/screenshots/$REPO/$story_number/checkpoint
\`\`\`

Run with: \`maestro test e2e/checkpoint-$story_number.yaml\`

**Commit the flow file** - it becomes a regression test:
\`\`\`bash
git add e2e/
git commit -m "test: add maestro flow for #$story_number"
\`\`\`

**C. If neither works (complex native setup):**
Document what needs manual verification and why automated testing isn't possible.

## Screenshots

Screenshots are saved outside the repo for reference:
\`~/.ralph/screenshots/$REPO/$story_number/\`

Create the directory if needed:
\`\`\`bash
mkdir -p ~/.ralph/screenshots/$REPO/$story_number
\`\`\`

## If Everything Passes

Close this issue with a summary of what was actually verified:
\`\`\`bash
gh issue close $story_number --comment "✅ Checkpoint passed

**Verified:**
- [specific user flow that was tested]
- [what was confirmed working]
- [edge cases checked]"
\`\`\`

## If Issues Found

1. Add a comment to this issue describing the problems found
2. Create new story issues to fix the problems:
   \`\`\`bash
   gh issue create --title "FIX-XXX: [description]" --body "..." --label "$RALPH_STORY_LABEL"
   \`\`\`
3. Link them as sub-issues to the parent (#$PARENT_NUMBER):
   \`\`\`bash
   PARENT_ID=\$(gh issue view $PARENT_NUMBER --json id --jq '.id')
   CHILD_ID=\$(gh issue view [NEW_ISSUE_NUMBER] --json id --jq '.id')
   gh api graphql -f query='mutation(\$p: ID!, \$c: ID!) { addSubIssue(input: {issueId: \$p, subIssueId: \$c}) { subIssue { id } } }' -f p="\$PARENT_ID" -f c="\$CHILD_ID"
   \`\`\`
4. Do NOT close this checkpoint - it will be re-run after fixes

## Important

- This is a VERIFICATION task, not implementation
- Test the actual running application
- Take screenshots as evidence
- Be thorough - check edge cases
- If the dev server isn't running, start it
- Clean up any test files after verification (except screenshots)
PROMPT_END
  else
    cat <<PROMPT_END
You are an autonomous coding agent working on a software project.

# Context

**Feature:** $PARENT_TITLE
**Branch:** $BRANCH_NAME
**Repository:** $REPO

## What's Been Done
$completed_stories

## Git Changes in This Branch
\`\`\`
$git_diff_stat
\`\`\`

## Recent Progress Notes
$recent_comments

# Your Task: Implement Story

**Issue:** #$story_number - $story_title

$story_body

## Instructions

1. Ensure you're on branch \`$BRANCH_NAME\`. If it doesn't exist, create it from main.
2. Read the acceptance criteria carefully
3. Implement the story - keep changes focused and minimal
4. Run quality checks (typecheck, lint, tests)
5. Commit with message: \`feat(#$story_number): $story_title\`
6. Close the issue with a progress comment

## Closing the Issue

When done, close with a summary:
\`\`\`bash
gh issue close $story_number --comment "$(
      cat <<'EOF'
## Completed

**Implemented:**
- What was built

**Files changed:**
- file1.ts
- file2.ts

**Notes for next iteration:**
- Any patterns discovered
- Things to watch out for
EOF
    )"
\`\`\`

## Quality Requirements

- ALL commits must pass quality checks
- Do NOT commit broken code
- Follow existing code patterns
- Keep changes minimal and focused

## Important

- Work on THIS story only
- Do not modify other issues
- If blocked, add a comment explaining why and stop
PROMPT_END
  fi
}

# ═══════════════════════════════════════════════════════════════════════════
# Main loop
# ═══════════════════════════════════════════════════════════════════════════

print_header "Starting Ralph Wiggum 2.0"
print_status "Repository: $REPO"
print_status "Spec: #$PARENT_NUMBER - $PARENT_TITLE"
print_status "Branch: $BRANCH_NAME"
print_status "Max iterations: $MAX_ITERATIONS"
print_status "Agent: $AGENT_CMD"

# Get initial sub-issues status
SUB_ISSUES=$(gh_get_sub_issues "$PARENT_ID")
TOTAL=$(echo "$SUB_ISSUES" | jq 'length')
DONE=$(echo "$SUB_ISSUES" | jq '[.[] | select(.state == "CLOSED")] | length')

# Check if there are no sub-issues
if [ "$TOTAL" -eq 0 ]; then
  print_warning "No sub-issues found for this spec!"
  print_status "Would you like to generate stories from the spec? (y/n)"
  read -r response
  if [[ $response =~ ^[Yy] ]]; then
    print_status "Generating stories from spec..."

    # Generate stories from the parent issue body
    read -r -d '' GENERATE_PROMPT <<GENERATE_END || true
You are a product manager helping to break down a feature specification into stories.

# Parent Spec Issue

**Title:** $PARENT_TITLE
**Issue:** #$PARENT_NUMBER

**Body:**
$PARENT_BODY

# Your Task

Analyze this spec and create individual story issues as sub-issues.

## Rules

1. Each story must be completable in ONE iteration (one context window)
2. Order by dependency: database → backend → UI
3. Include checkpoints at integration points
4. Always end with E2E-FINAL checkpoint
5. Use label \`$RALPH_STORY_LABEL\` for stories
6. Use labels \`$RALPH_STORY_LABEL,$RALPH_CHECKPOINT_LABEL\` for checkpoints

## Creating and Linking Issues

For each story:
\`\`\`bash
# Create the story
gh issue create --title "US-001: [title]" --body "[body]" --label "$RALPH_STORY_LABEL"

# Get IDs and link
PARENT_ID=\$(gh issue view $PARENT_NUMBER --json id --jq '.id')
CHILD_ID=\$(gh issue view [CHILD_NUMBER] --json id --jq '.id')
gh api graphql -f query='mutation(\$parent: ID!, \$child: ID!) { addSubIssue(input: {issueId: \$parent, subIssueId: \$child}) { subIssue { id } } }' -f parent="\$PARENT_ID" -f child="\$CHILD_ID"
\`\`\`

Create all stories now, then I will start implementing them.
GENERATE_END

    echo "$GENERATE_PROMPT" | $AGENT_CMD 2>&1 | tee /dev/stderr || true

    # Refresh sub-issues
    SUB_ISSUES=$(gh_get_sub_issues "$PARENT_ID")
    TOTAL=$(echo "$SUB_ISSUES" | jq 'length')
    DONE=$(echo "$SUB_ISSUES" | jq '[.[] | select(.state == "CLOSED")] | length')

    if [ "$TOTAL" -eq 0 ]; then
      print_error "No stories were created. Please check the agent output."
      exit 1
    fi

    print_status "Created $TOTAL stories"
  else
    print_error "Cannot run without sub-issues. Create them with ralph --new or manually."
    exit 1
  fi
fi

print_status "Progress: $DONE/$TOTAL stories complete"
echo ""

for i in $(seq 1 "$MAX_ITERATIONS"); do
  print_header "Iteration $i of $MAX_ITERATIONS"

  # Refresh sub-issues list
  SUB_ISSUES=$(gh_get_sub_issues "$PARENT_ID")
  DONE=$(echo "$SUB_ISSUES" | jq '[.[] | select(.state == "CLOSED")] | length')
  TOTAL=$(echo "$SUB_ISSUES" | jq 'length')

  # Check if all done
  if [ "$DONE" -eq "$TOTAL" ] && [ "$TOTAL" -gt 0 ]; then
    print_status "All stories complete!"

    # Add completion comment to parent issue
    gh_add_comment "$PARENT_NUMBER" "## ✅ Ralph Completed

All $TOTAL stories have been implemented and verified.

**Completed at:** $(date)
**Iterations:** $i"

    # Remove lock and close parent if desired
    print_status "Finished at iteration $i of $MAX_ITERATIONS"
    print_status "You may want to close the parent issue #$PARENT_NUMBER"
    exit 0
  fi

  # Find next open story (prefer non-checkpoints first, unless all non-checkpoints are done)
  NEXT_STORY=$(echo "$SUB_ISSUES" | jq -r '
    [.[] | select(.state == "OPEN")] |
    (map(select(.labels.nodes | map(.name) | contains(["ralph-checkpoint"]) | not)) | first) //
    (first)
  ')

  if [ "$NEXT_STORY" = "null" ] || [ -z "$NEXT_STORY" ]; then
    print_warning "No open stories found but not all complete. Check issue state."
    sleep 5
    continue
  fi

  STORY_NUMBER=$(echo "$NEXT_STORY" | jq -r '.number')
  STORY_TITLE=$(echo "$NEXT_STORY" | jq -r '.title')
  STORY_LABELS=$(echo "$NEXT_STORY" | jq -r '.labels.nodes[].name' 2>/dev/null | tr '\n' ',' || echo "")

  IS_CHECKPOINT="false"
  if [[ $STORY_LABELS =~ $RALPH_CHECKPOINT_LABEL ]]; then
    IS_CHECKPOINT="true"
  fi

  print_status "Working on: #$STORY_NUMBER - $STORY_TITLE"
  if [ "$IS_CHECKPOINT" = "true" ]; then
    print_status "Type: E2E Checkpoint"
  fi

  # Get story details
  STORY_DETAILS=$(gh_get_issue "$STORY_NUMBER")
  STORY_BODY=$(echo "$STORY_DETAILS" | jq -r '.body')

  # Get comments from this story (previous attempts, notes, etc.)
  STORY_COMMENTS=$(gh_get_comments "$STORY_NUMBER" 5 | jq -r '.[] | "### \(.author.login) (\(.createdAt))\n\(.body)\n"' 2>/dev/null || echo "")

  # Get recent comments from parent for broader context
  PARENT_COMMENTS=$(gh_get_comments "$PARENT_NUMBER" 3 | jq -r '.[] | "### \(.author.login) (\(.createdAt))\n\(.body)\n"' 2>/dev/null || echo "")

  # Combine comments
  RECENT_COMMENTS=""
  if [ -n "$STORY_COMMENTS" ]; then
    RECENT_COMMENTS="### Comments on this story:\n$STORY_COMMENTS\n"
  fi
  if [ -n "$PARENT_COMMENTS" ]; then
    RECENT_COMMENTS="${RECENT_COMMENTS}### Comments on parent spec:\n$PARENT_COMMENTS"
  fi
  if [ -z "$RECENT_COMMENTS" ]; then
    RECENT_COMMENTS="No recent comments"
  fi

  # Get git diff stat for the branch
  GIT_DIFF_STAT=$(git diff main..."$BRANCH_NAME" --stat 2>/dev/null || echo "Branch not yet created or no changes")

  # Get completed stories summary
  COMPLETED_STORIES=$(echo "$SUB_ISSUES" | jq -r '.[] | select(.state == "CLOSED") | "- #\(.number): \(.title)"' || echo "None yet")

  # Generate the prompt
  PROMPT=$(generate_prompt "$STORY_NUMBER" "$STORY_TITLE" "$STORY_BODY" "$IS_CHECKPOINT" "$RECENT_COMMENTS" "$GIT_DIFF_STAT" "$COMPLETED_STORIES")

  # Run the agent
  print_status "Launching agent..."
  echo "$PROMPT" | $AGENT_CMD 2>&1 | tee /dev/stderr || true

  # Check progress after iteration
  SUB_ISSUES=$(gh_get_sub_issues "$PARENT_ID")
  DONE=$(echo "$SUB_ISSUES" | jq '[.[] | select(.state == "CLOSED")] | length')

  print_status "Progress: $DONE/$TOTAL stories complete"
  print_status "Iteration $i complete. Continuing in 2 seconds..."
  sleep 2
done

echo ""
print_warning "Ralph reached max iterations ($MAX_ITERATIONS) without completing."
print_warning "Progress: $DONE/$TOTAL stories complete"
print_warning "Continue with: ralph $PARENT_NUMBER $((MAX_ITERATIONS * 2))"
exit 1
