#!/bin/bash
# Ralph Wiggum 2.0 - GitHub Issue-Based AI Agent Loop
# Named after the Simpsons character who never stops trying
#
# Usage:
#   ralph <issue-number>        Run the autonomous loop on a spec issue
#   ralph --new [feature-name]  Interactive spec authoring (creates GitHub issue)
#   ralph --status              Show status of all ralph specs in current repo
#
# Environment variables:
#   RALPH_AGENT_CMD - Command to invoke the agent (default: copilot)

set -e

# ═══════════════════════════════════════════════════════════════════════════
# Configuration
# ═══════════════════════════════════════════════════════════════════════════

AGENT_CMD="${RALPH_AGENT_CMD:-copilot}"
RALPH_LABEL="ralph-spec"
RALPH_RUNNING_LABEL="ralph-running"
RALPH_COMPLETED_LABEL="ralph-completed"

# Track if we're in the main loop (for cleanup)
RUNNING_ISSUE=""

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

# ═══════════════════════════════════════════════════════════════════════════
# Helper functions
# ═══════════════════════════════════════════════════════════════════════════

print_header() {
  echo ""
  echo -e "${BLUE}═══════════════════════════════════════════════════════${NC}"
  echo -e "${BLUE}  $1${NC}"
  echo -e "${BLUE}═══════════════════════════════════════════════════════${NC}"
}

print_status() {
  echo -e "${GREEN}[ralph]${NC} $1"
}

print_warning() {
  echo -e "${YELLOW}[ralph]${NC} $1"
}

print_error() {
  echo -e "${RED}[ralph]${NC} $1"
}

# Cleanup function - removes ralph-running label
cleanup() {
  if [ -n "$RUNNING_ISSUE" ]; then
    print_status "Cleaning up..."
    gh issue edit "$RUNNING_ISSUE" --remove-label "$RALPH_RUNNING_LABEL" 2>/dev/null || true
    RUNNING_ISSUE=""
  fi
}

# Trap signals for cleanup
trap cleanup EXIT INT TERM

usage() {
  echo "Ralph Wiggum 2.0 - GitHub Issue-Based AI Agent Loop"
  echo ""
  echo "Usage:"
  echo "  ralph <issue-number>        Run the autonomous loop on a spec issue"
  echo "  ralph --new [feature-name]  Interactive spec authoring"
  echo "  ralph --status              Show status of all ralph specs"
  echo ""
  echo "Environment variables:"
  echo "  RALPH_AGENT_CMD   Agent command (default: copilot)"
  exit 1
}

# Get current repo in owner/repo format
get_repo() {
  gh repo view --json nameWithOwner --jq '.nameWithOwner'
}

# Ensure ralph labels exist
ensure_labels() {
  if ! gh label list --json name --jq '.[].name' | grep -q "^${RALPH_LABEL}$"; then
    gh label create "$RALPH_LABEL" --description "Ralph spec issue" --color "5319E7" 2>/dev/null || true
  fi
  if ! gh label list --json name --jq '.[].name' | grep -q "^${RALPH_RUNNING_LABEL}$"; then
    gh label create "$RALPH_RUNNING_LABEL" --description "Ralph is currently running" --color "FFA500" 2>/dev/null || true
  fi
  if ! gh label list --json name --jq '.[].name' | grep -q "^${RALPH_COMPLETED_LABEL}$"; then
    gh label create "$RALPH_COMPLETED_LABEL" --description "Ralph completed all stories" --color "0E8A16" 2>/dev/null || true
  fi
}

# ═══════════════════════════════════════════════════════════════════════════
# Status command
# ═══════════════════════════════════════════════════════════════════════════

show_status() {
  print_header "Ralph Status"

  local repo
  repo=$(get_repo 2>/dev/null) || {
    print_error "Not in a git repository or gh CLI not authenticated"
    exit 1
  }

  print_status "Repository: $repo"
  echo ""

  # Get all issues with ralph-spec label
  local specs
  specs=$(gh issue list --label "$RALPH_LABEL" --state all --json number,title,state,body --jq '.[]' 2>/dev/null)

  if [ -z "$specs" ]; then
    echo "No ralph specs found in this repository."
    echo "Create one with: ralph --new"
    exit 0
  fi

  gh issue list --label "$RALPH_LABEL" --state all --json number,title,state,body,labels | jq -c '.[]' | while read -r spec; do
    local number title state body labels
    number=$(echo "$spec" | jq -r '.number')
    title=$(echo "$spec" | jq -r '.title')
    state=$(echo "$spec" | jq -r '.state')
    body=$(echo "$spec" | jq -r '.body')
    labels=$(echo "$spec" | jq -r '.labels[].name' | tr '\n' ' ')

    # Count checkboxes
    local total done
    total=$(echo "$body" | grep -c '^\- \[.\]' || echo "0")
    done=$(echo "$body" | grep -c '^\- \[x\]' || echo "0")

    # Format state based on labels and issue state
    local state_display
    if echo "$labels" | grep -q "$RALPH_RUNNING_LABEL"; then
      state_display="${YELLOW}RUNNING${NC}"
    elif echo "$labels" | grep -q "$RALPH_COMPLETED_LABEL"; then
      state_display="${GREEN}COMPLETED${NC}"
    elif [ "$state" = "CLOSED" ]; then
      state_display="${GREEN}CLOSED${NC}"
    elif [ "$done" -eq "$total" ] && [ "$total" -gt 0 ]; then
      state_display="${GREEN}READY TO CLOSE${NC}"
    else
      state_display="${CYAN}PENDING${NC}"
    fi

    echo -e "${BOLD}#$number: $title${NC} [$state_display]"
    echo -e "  Progress: ${GREEN}$done${NC}/${total} stories complete"

    # Show next story
    local next_story
    next_story=$(echo "$body" | grep '^\- \[ \]' | head -1 | sed 's/^- \[ \] //')
    if [ -n "$next_story" ]; then
      echo -e "  Next: $next_story"
    fi
    echo ""
  done

  exit 0
}

# ═══════════════════════════════════════════════════════════════════════════
# New spec command
# ═══════════════════════════════════════════════════════════════════════════

new_spec() {
  local feature_name="${1:-}"

  print_header "New Spec - Interactive Mode"

  local repo
  repo=$(get_repo 2>/dev/null) || {
    print_error "Not in a git repository or gh CLI not authenticated"
    exit 1
  }

  print_status "Repository: $repo"
  ensure_labels

  if [ -n "$feature_name" ]; then
    print_status "Feature name: $feature_name"
  fi

  echo ""

  # Prompt for the agent
  read -r -d '' PROMPT <<'PROMPT_END' || true
You are a product manager helping to create a feature specification. Your job is to interview the user, understand what they want to build, and create a GitHub issue with the spec.

# Your Task

1. Ask what feature or change they want to build (if not already clear)
2. Ask 3-5 essential clarifying questions to understand:
   - **Problem/Goal:** What problem does this solve? Why build it?
   - **Core Functionality:** What are the key user actions?
   - **Scope/Boundaries:** What should it NOT do?
   - **Success Criteria:** How do we know it's done?

3. Format questions with lettered options for quick responses:
   ```
   1. What is the primary goal?
      A. Improve user experience
      B. Add new capability
      C. Fix existing pain point
      D. Other: [please specify]
   ```

4. After gathering answers, create the GitHub issue.

# Issue Format

Create an issue with this structure:

**Title:** `[Feature Name]`
**Label:** `ralph-spec`

**Body:**
```markdown
## Overview
Brief description of the feature and the problem it solves.

## Branch
`ralph/[feature-name-kebab-case]`

## Stories

- [ ] US-001: [Story title] - [Brief description]
- [ ] US-002: [Story title] - [Brief description]
- [ ] CHECKPOINT: Verify [what to verify]
- [ ] US-003: [Story title] - [Brief description]
- [ ] E2E-FINAL: Validate complete feature

## Non-Goals
What this feature will NOT include.
```

# Story Rules

**Sizing:** Each story must be completable in ONE agent session.
- Good: "Add users table", "Add signup API endpoint", "Add signup form"
- Too big: "Add authentication" → split into multiple stories

**Ordering:** Stories are processed IN ORDER. Place checkpoints where verification should happen:
1. Database/schema changes first
2. Backend/API logic
3. CHECKPOINT: Verify backend works
4. UI components
5. CHECKPOINT: Verify UI works
6. E2E-FINAL: Always last

**Checkpoints:** These verify previous work before continuing. They run Playwright (web) or Maestro (mobile) tests.

# Creating the Issue

Use this command:
```bash
gh issue create --title "Feature Name" --label "ralph-spec" --body "..."
```

After creating, tell the user the issue number so they can run `ralph <number>`.

# Important

- Do NOT implement anything - just create the spec issue
- Ask questions FIRST, then create the issue
- Stories are processed in order - checkpoint placement matters
- Keep stories small and focused
PROMPT_END

  if [ -n "$feature_name" ]; then
    PROMPT="$PROMPT

The user wants to build a feature called: $feature_name"
  fi

  $AGENT_CMD -i "$PROMPT"
  exit 0
}

# ═══════════════════════════════════════════════════════════════════════════
# Parse issue for stories
# ═══════════════════════════════════════════════════════════════════════════

# Get the next unchecked story from issue body
# Returns: "index|title" or empty if all done
get_next_story() {
  local body="$1"
  local index=0

  while IFS= read -r line; do
    if echo "$line" | grep -q '^\- \[ \]'; then
      local title
      title=$(echo "$line" | sed 's/^- \[ \] //')
      echo "$index|$title"
      return 0
    fi
    if echo "$line" | grep -q '^\- \[.\]'; then
      index=$((index + 1))
    fi
  done <<<"$body"

  echo ""
}

# Check if a story title indicates it's a checkpoint
is_checkpoint() {
  local title="$1"
  echo "$title" | grep -qi "checkpoint\|e2e-final\|verify\|validate"
}

# Mark a story as complete by updating issue body
mark_story_complete() {
  local issue_number="$1"
  local story_index="$2"

  local body
  body=$(gh issue view "$issue_number" --json body --jq '.body')

  # Replace the nth unchecked checkbox with checked
  local count=0
  local new_body=""
  while IFS= read -r line; do
    if echo "$line" | grep -q '^\- \[ \]' && [ "$count" -eq "$story_index" ]; then
      line=$(echo "$line" | sed 's/^\- \[ \]/- [x]/')
    fi
    if echo "$line" | grep -q '^\- \[.\]'; then
      count=$((count + 1))
    fi
    new_body="$new_body$line
"
  done <<<"$body"

  gh issue edit "$issue_number" --body "$new_body"
}

# ═══════════════════════════════════════════════════════════════════════════
# Generate prompts
# ═══════════════════════════════════════════════════════════════════════════

generate_story_prompt() {
  local issue_number="$1"
  local issue_title="$2"
  local story_title="$3"
  local branch_name="$4"
  local completed_stories="$5"
  local repo="$6"

  cat <<PROMPT_END
You are an autonomous coding agent working on a software project.

# Context

**Feature:** $issue_title
**Branch:** $branch_name
**Repository:** $repo
**Spec Issue:** #$issue_number

## Completed Stories
$completed_stories

# Your Task

Implement this story: **$story_title**

## Instructions

1. Make sure you're on branch \`$branch_name\`. Create it from main if it doesn't exist.
2. Implement the story - keep changes focused and minimal.
3. Run quality checks (typecheck, lint, tests as appropriate).
4. Commit with message: \`feat: $story_title (#$issue_number)\`
5. Add a comment to issue #$issue_number summarizing what you did.

## Adding Progress Comment

When done, add a comment:
\`\`\`bash
gh issue comment $issue_number --body "## $story_title

**Implemented:**
- What was built

**Files changed:**
- list files

**Notes:**
- Any patterns or gotchas for future stories"
\`\`\`

## Quality Requirements

- All commits must pass quality checks
- Do NOT commit broken code
- Follow existing code patterns
- Keep changes minimal and focused

## Important

- Work on THIS story only
- Do not modify other stories or the spec
- If blocked, add a comment explaining why
PROMPT_END
}

generate_checkpoint_prompt() {
  local issue_number="$1"
  local issue_title="$2"
  local story_title="$3"
  local branch_name="$4"
  local completed_stories="$5"
  local repo="$6"

  cat <<PROMPT_END
You are an autonomous coding agent performing E2E validation.

# Context

**Feature:** $issue_title
**Branch:** $branch_name
**Repository:** $repo
**Spec Issue:** #$issue_number

## Completed Stories
$completed_stories

# Your Task: CHECKPOINT

**$story_title**

Verify that the implemented stories work correctly end-to-end.

## E2E Testing Setup

### Step 1: Detect Package Manager

Check which lockfile exists:
- \`bun.lockb\` → use \`bunx\`
- \`pnpm-lock.yaml\` → use \`pnpm dlx\`
- \`yarn.lock\` → use \`yarn dlx\`
- \`package-lock.json\` or none → use \`npx\`

### Step 2: For Web Apps (Next.js, React, etc.)

Use Playwright:
\`\`\`bash
# Install if needed
[runner] playwright install chromium

# Write test in e2e/ directory
# Run: [runner] playwright test e2e/checkpoint-xxx.spec.ts
\`\`\`

### Step 3: For React Native / Expo

**If web-compatible (no native modules):**
- Run \`[runner] expo start --web\`
- Use Playwright against localhost

**If using custom dev client (native modules):**
Use Maestro:
\`\`\`bash
# Install if needed
curl -Ls "https://get.maestro.mobile.dev" | bash

# Write flow in e2e/ directory
# Run: maestro test e2e/checkpoint-xxx.yaml
\`\`\`

## Save Tests to Repo

Save test files to \`e2e/\` directory and commit them - they become regression tests.

## If Checkpoint Passes

Add a comment and you're done:
\`\`\`bash
gh issue comment $issue_number --body "## ✅ $story_title

**Verified:**
- What was tested
- What passed"
\`\`\`

## If Issues Found

1. Add a comment describing the problems
2. Do NOT mark this checkpoint complete
3. The next run will retry this checkpoint after issues are fixed

## Important

- This is VERIFICATION, not implementation
- Actually run the app and test it
- Be thorough - check edge cases
PROMPT_END
}

# ═══════════════════════════════════════════════════════════════════════════
# Argument parsing
# ═══════════════════════════════════════════════════════════════════════════

if [ -z "$1" ] || [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
  usage
fi

if [ "$1" = "--status" ]; then
  show_status
fi

if [ "$1" = "--new" ]; then
  new_spec "$2"
fi

# ═══════════════════════════════════════════════════════════════════════════
# Main loop
# ═══════════════════════════════════════════════════════════════════════════

ISSUE_NUMBER="$1"
MAX_ITERATIONS="${2:-100}"

# Verify repo
REPO=$(get_repo 2>/dev/null) || {
  print_error "Not in a git repository or gh CLI not authenticated"
  exit 1
}

# Get issue details
ISSUE=$(gh issue view "$ISSUE_NUMBER" --json number,title,body,state,labels 2>/dev/null) || {
  print_error "Issue #$ISSUE_NUMBER not found"
  exit 1
}

ISSUE_TITLE=$(echo "$ISSUE" | jq -r '.title')
ISSUE_BODY=$(echo "$ISSUE" | jq -r '.body')
ISSUE_STATE=$(echo "$ISSUE" | jq -r '.state')

if [ "$ISSUE_STATE" = "CLOSED" ]; then
  print_error "Issue #$ISSUE_NUMBER is closed"
  exit 1
fi

# Extract branch name from issue body
BRANCH_NAME=$(echo "$ISSUE_BODY" | grep -o '`ralph/[^`]*`' | head -1 | tr -d '`' || echo "")
if [ -z "$BRANCH_NAME" ]; then
  BRANCH_NAME="ralph/$(echo "$ISSUE_TITLE" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-//' | sed 's/-$//')"
fi

# Ensure labels exist
ensure_labels

# Add spec label if missing
if ! echo "$ISSUE" | jq -r '.labels[].name' | grep -q "^${RALPH_LABEL}$"; then
  gh issue edit "$ISSUE_NUMBER" --add-label "$RALPH_LABEL" 2>/dev/null || true
fi

# Add running label and set up cleanup (remove completed if re-running)
RUNNING_ISSUE="$ISSUE_NUMBER"
gh issue edit "$ISSUE_NUMBER" --add-label "$RALPH_RUNNING_LABEL" --remove-label "$RALPH_COMPLETED_LABEL" 2>/dev/null || true

print_header "Starting Ralph"
print_status "Repository: $REPO"
print_status "Issue: #$ISSUE_NUMBER - $ISSUE_TITLE"
print_status "Branch: $BRANCH_NAME"
print_status "Max iterations: $MAX_ITERATIONS"

# Count stories
TOTAL=$(echo "$ISSUE_BODY" | grep -c '^\- \[.\]' || echo "0")
DONE=$(echo "$ISSUE_BODY" | grep -c '^\- \[x\]' || echo "0")
print_status "Progress: $DONE/$TOTAL stories"
echo ""

# Main loop
for i in $(seq 1 "$MAX_ITERATIONS"); do
  print_header "Iteration $i of $MAX_ITERATIONS"

  # Refresh issue body
  ISSUE_BODY=$(gh issue view "$ISSUE_NUMBER" --json body --jq '.body')

  # Get completed stories for context
  COMPLETED=$(echo "$ISSUE_BODY" | grep '^\- \[x\]' | sed 's/^- \[x\] /- /' || echo "None yet")

  # Get next story
  NEXT=$(get_next_story "$ISSUE_BODY")

  if [ -z "$NEXT" ]; then
    print_status "All stories complete!"

    # Update labels: remove running, add completed
    gh issue edit "$ISSUE_NUMBER" --remove-label "$RALPH_RUNNING_LABEL" --add-label "$RALPH_COMPLETED_LABEL" 2>/dev/null || true
    RUNNING_ISSUE="" # Prevent cleanup from running again

    gh issue comment "$ISSUE_NUMBER" --body "## ✅ Ralph Complete

All stories have been implemented and verified.

**Completed at:** $(date)"

    print_status "You may want to close issue #$ISSUE_NUMBER"
    exit 0
  fi

  STORY_INDEX=$(echo "$NEXT" | cut -d'|' -f1)
  STORY_TITLE=$(echo "$NEXT" | cut -d'|' -f2-)

  print_status "Working on: $STORY_TITLE"

  # Generate appropriate prompt
  if is_checkpoint "$STORY_TITLE"; then
    print_status "Type: Checkpoint"
    PROMPT=$(generate_checkpoint_prompt "$ISSUE_NUMBER" "$ISSUE_TITLE" "$STORY_TITLE" "$BRANCH_NAME" "$COMPLETED" "$REPO")
  else
    PROMPT=$(generate_story_prompt "$ISSUE_NUMBER" "$ISSUE_TITLE" "$STORY_TITLE" "$BRANCH_NAME" "$COMPLETED" "$REPO")
  fi

  # Run agent
  print_status "Launching agent..."
  echo "$PROMPT" | $AGENT_CMD || true

  # Ask if story was completed
  echo ""
  print_status "Was this story completed successfully? (y/n)"
  read -r completed

  if [[ $completed =~ ^[Yy] ]]; then
    print_status "Marking story complete..."
    mark_story_complete "$ISSUE_NUMBER" "$STORY_INDEX"

    # Update counts
    DONE=$((DONE + 1))
    print_status "Progress: $DONE/$TOTAL stories"
  else
    print_warning "Story not completed. Will retry on next iteration."
  fi

  print_status "Continuing in 2 seconds..."
  sleep 2
done

print_warning "Reached max iterations ($MAX_ITERATIONS)"
print_warning "Progress: $DONE/$TOTAL stories"
print_warning "Continue with: ralph $ISSUE_NUMBER"
exit 1
