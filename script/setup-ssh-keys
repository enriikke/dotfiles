#!/usr/bin/env bash

set -e

# Source shared helpers
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=script/common.sh
. "$script_dir/common.sh"

# Configuration
SSH_DIR="$HOME/.ssh"
WORK_CONFIG_NAME="${WORK_CONFIG_NAME:-SSH Work Config}" # Name in 1Password
WORK_CONFIG_PATH="$SSH_DIR/config.work"

check_prerequisites() {
  print_header "Checking Prerequisites"

  # Check if op CLI is installed
  if ! command -v op >/dev/null 2>&1; then
    print_error "1Password CLI (op) not found"
    print_status "Install with: brew install 1password-cli"
    return 1
  fi
  print_status "âœ“ 1Password CLI found"

  # Check if signed in
  if ! op account list >/dev/null 2>&1; then
    print_error "1Password CLI not signed in"
    print_status "Sign in with: op signin"
    return 1
  fi
  print_status "âœ“ 1Password CLI signed in"

  return 0
}

list_ssh_keys() {
  local keys_output
  if ! keys_output=$(op item list --categories="SSH Key" --format=json 2>/dev/null); then
    print_error "Failed to list SSH keys from 1Password"
    return 1
  fi

  # Parse JSON to get key names
  local key_names=()
  while IFS= read -r line; do
    [[ -n $line ]] && key_names+=("$line")
  done < <(echo "$keys_output" | jq -r '.[].title' 2>/dev/null || echo "")

  if [[ ${#key_names[@]} -eq 0 ]]; then
    print_error "No SSH keys found in 1Password"
    print_status "Create SSH keys in 1Password:"
    print_status "1. Open 1Password app"
    print_status "2. Click '+' â†’ 'SSH Key'"
    print_status "3. Either 'Import Existing' or 'Generate New'"
    return 1
  fi

  echo "${key_names[@]}"
}

download_ssh_key() {
  local key_name="$1"
  local key_path="$2"
  local key_type="$3" # "private" or "public"

  print_status "Downloading $key_type key: $key_name"

  # Download key directly
  if op item get "$key_name" --field "$key_type key" >"$key_path" 2>/dev/null; then
    # Set appropriate permissions
    if [[ $key_type == "private" ]]; then
      chmod 600 "$key_path"
    else
      chmod 644 "$key_path"
    fi
    print_status "âœ“ $key_type key saved: $key_path"
    return 0
  else
    print_error "âœ— Failed to download $key_type key: $key_name"
    rm -f "$key_path" # Clean up on failure
    return 1
  fi
}

download_work_ssh_config() {
  print_header "Checking for Work SSH Config"

  # Check if work SSH config exists in 1Password
  if ! op item get "$WORK_CONFIG_NAME" >/dev/null 2>&1; then
    print_warning "Work SSH config '$WORK_CONFIG_NAME' not found in 1Password"
    print_status "Skipping work SSH config setup"
    print_status ""
    print_status "To store your work SSH config in 1Password:"
    print_status "1. Open 1Password app"
    print_status "2. Click '+' â†’ 'Secure Note'"
    print_status "3. Title: '$WORK_CONFIG_NAME'"
    print_status "4. Paste your work SSH config in the notes field"
    print_status "5. Save"
    return 0
  fi

  print_status "Found work SSH config: $WORK_CONFIG_NAME"

  # Download the config content
  if op item get "$WORK_CONFIG_NAME" --field notesPlain >"$WORK_CONFIG_PATH" 2>/dev/null; then
    chmod 644 "$WORK_CONFIG_PATH"
    print_status "âœ“ Work SSH config saved: $WORK_CONFIG_PATH"

    # Validate it looks like SSH config
    if grep -q "Host\|HostName\|User\|IdentityFile" "$WORK_CONFIG_PATH" 2>/dev/null; then
      print_status "âœ“ Work SSH config appears valid"
    else
      print_warning "Work SSH config doesn't look like SSH configuration"
      print_status "Please verify the content in 1Password"
    fi

    return 0
  else
    print_error "âœ— Failed to download work SSH config"
    rm -f "$WORK_CONFIG_PATH"
    return 1
  fi
}

process_ssh_keys() {
  local keys=("$@")
  local success_count=0
  local failed_keys=()

  print_header "Processing SSH Keys"

  for key_name in "${keys[@]}"; do
    print_status "Processing: $key_name"

    # Generate file paths (normalize key name for filename)
    local safe_name
    safe_name=$(echo "$key_name" | tr ' ' '_' | tr -cd '[:alnum:]._-')
    local private_path="$SSH_DIR/id_rsa_${safe_name}"
    local public_path="$SSH_DIR/id_rsa_${safe_name}.pub"

    # Download private and public keys
    local private_ok=false
    local public_ok=false

    if download_ssh_key "$key_name" "$private_path" "private"; then
      private_ok=true
    fi

    if download_ssh_key "$key_name" "$public_path" "public"; then
      public_ok=true
    fi

    # Track results
    if [[ $private_ok == true && $public_ok == true ]]; then
      ((success_count++))
      print_status "âœ“ Successfully processed: $key_name"
    else
      failed_keys+=("$key_name")
      print_warning "âœ— Failed to process: $key_name"
    fi

    echo "" # Add spacing between keys
  done

  # Return results via global variables (bash limitation workaround)
  PROCESSED_COUNT=$success_count
  FAILED_KEYS=("${failed_keys[@]}")
}

show_summary() {
  local total_keys=$1
  local success_count=$2
  shift 2
  local failed_keys=("$@")

  print_header "Summary"

  # SSH Keys Summary
  if [[ $success_count -eq $total_keys ]]; then
    print_status "ðŸŽ‰ All $total_keys SSH key(s) processed successfully!"
  else
    print_status "Processed $success_count out of $total_keys SSH key(s)"

    if [[ ${#failed_keys[@]} -gt 0 ]]; then
      print_warning "Failed keys:"
      for key in "${failed_keys[@]}"; do
        print_warning "  â€¢ $key"
      done
    fi
  fi

  # Work Config Summary
  if [[ -f $WORK_CONFIG_PATH ]]; then
    print_status "âœ“ Work SSH config installed: $WORK_CONFIG_PATH"
  else
    print_status "â—‹ No work SSH config (optional)"
  fi

  echo ""
  print_status "SSH setup complete! Files created in $SSH_DIR:"

  # Show downloaded files
  find "$SSH_DIR" -maxdepth 1 -name "id_rsa*" -o -name "config.work" | sort | while read -r file; do
    if [[ -f $file ]]; then
      local perms basename_file
      perms=$(stat -f "%Mp%Lp" "$file" 2>/dev/null || stat -c "%a" "$file" 2>/dev/null || echo "???")
      basename_file=$(basename "$file")
      print_status "  $basename_file ($perms)"
    fi
  done

  echo ""
  print_status "Your SSH and Git configurations (from dotfiles) will handle the rest!"
  print_status "Test with: ssh -T git@github.com"
}

show_usage() {
  echo "Usage: $0 [OPTIONS] [KEY_NAME...]"
  echo ""
  echo "Download SSH keys and work config from 1Password to ~/.ssh/"
  echo ""
  echo "OPTIONS:"
  echo "  --work-config NAME    Name of work SSH config in 1Password"
  echo "                        (default: 'SSH Work Config')"
  echo "  -h, --help           Show this help message"
  echo ""
  echo "ARGUMENTS:"
  echo "  KEY_NAME             Specific SSH key name(s) to download"
  echo "                       If not provided, downloads all available keys"
  echo ""
  echo "EXAMPLES:"
  echo "  $0                                    # Download all keys + work config"
  echo "  $0 'Git Signing Key'                 # Download specific key + work config"
  echo "  $0 --work-config 'My Work SSH'       # Use custom work config name"
  echo ""
  echo "1PASSWORD SETUP:"
  echo "  SSH Keys: 1Password app â†’ + â†’ SSH Key â†’ Import/Generate"
  echo "  Work Config: 1Password app â†’ + â†’ Secure Note â†’ Title: 'SSH Work Config'"
  echo ""
  echo "PREREQUISITES:"
  echo "  â€¢ 1Password CLI (op) installed and signed in"
  echo "  â€¢ SSH keys stored in 1Password"
  echo "  â€¢ Dotfiles repo stowed (for main SSH config)"
}

main() {
  # Parse command line arguments
  local keys_to_process=()

  while [[ $# -gt 0 ]]; do
    case $1 in
      --work-config)
        WORK_CONFIG_NAME="$2"
        shift 2
        ;;
      -h | --help)
        show_usage
        exit 0
        ;;
      -*)
        print_error "Unknown option: $1"
        show_usage
        exit 1
        ;;
      *)
        keys_to_process+=("$1")
        shift
        ;;
    esac
  done

  print_header "1Password SSH Setup"
  echo ""

  # Check prerequisites
  if ! check_prerequisites; then
    exit 1
  fi

  # Determine which SSH keys to process
  if [[ ${#keys_to_process[@]} -eq 0 ]]; then
    # Download all available keys
    print_header "Available SSH Keys in 1Password"

    local available_keys
    if ! available_keys=$(list_ssh_keys); then
      exit 1
    fi

    # Convert to array
    read -ra keys_to_process <<<"$available_keys"

    if [[ ${#keys_to_process[@]} -eq 0 ]]; then
      print_error "No SSH keys available"
      exit 1
    fi

    print_status "Found ${#keys_to_process[@]} SSH key(s):"
    for i in "${!keys_to_process[@]}"; do
      echo "  $((i + 1)). ${keys_to_process[i]}"
    done
    echo ""
    print_status "Will download all ${#keys_to_process[@]} key(s)"
  else
    # Use provided key names
    print_status "Will download ${#keys_to_process[@]} specified key(s)"
  fi

  echo ""

  # Process SSH keys
  process_ssh_keys "${keys_to_process[@]}"

  # Download work SSH config (optional)
  download_work_ssh_config

  # Show summary
  show_summary "${#keys_to_process[@]}" "$PROCESSED_COUNT" "${FAILED_KEYS[@]}"
}

# Run main function if script is executed directly
if [[ ${BASH_SOURCE[0]} == "${0}" ]]; then
  main "$@"
fi
