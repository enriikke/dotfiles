#!/usr/bin/env bash

set -e

# Source shared helpers
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=script/common.sh
. "$script_dir/common.sh"

# Configuration
SSH_DIR="$HOME/.ssh"
WORK_CONFIG_NAME="${WORK_CONFIG_NAME:-SSH Work Config}" # Name in 1Password
WORK_CONFIG_PATH="$SSH_DIR/config.work"
DEFAULT_KEY_NAME="${DEFAULT_KEY_NAME:-}" # Optional: title to link as id_rsa

check_prerequisites() {
  print_header "Checking Prerequisites"

  # Check jq availability (required for parsing JSON)
  if ! command -v jq >/dev/null 2>&1; then
    print_error "jq not found (required to parse 1Password output)"
    print_status "Install with: brew install jq (or your package manager)"
    return 1
  fi
  print_status "âœ“ jq found"

  # Check if op CLI is installed
  if ! command -v op >/dev/null 2>&1; then
    print_error "1Password CLI (op) not found"
    print_status "Install with: brew install 1password-cli"
    return 1
  fi
  print_status "âœ“ 1Password CLI found"

  # Check if signed in
  if ! op account list >/dev/null 2>&1; then
    print_error "1Password CLI not signed in"
    print_status "Sign in with: op signin"
    return 1
  fi
  print_status "âœ“ 1Password CLI signed in"

  return 0
}

ensure_ssh_dir() {
  mkdir -p "$SSH_DIR"
  chmod 700 "$SSH_DIR" 2>/dev/null || true
}

# Determine key algorithm/type from 1Password item metadata.
# Returns one of: ed25519 | rsa | unknown
get_key_type() {
  local key_name="$1"
  local raw
  if ! raw=$(op item get "$key_name" --format json 2>/dev/null); then
    printf '%s\n' unknown
    return 1
  fi
  # Extract the "key type" field (case-insensitive), then normalize
  local val
  val=$(printf '%s' "$raw" | jq -r '.fields[]? | select((.label // "") | ascii_downcase == "key type") | .value' 2>/dev/null)
  val=$(printf '%s' "$val" | tr '[:upper:]' '[:lower:]')
  if [[ -z $val ]]; then
    printf '%s\n' unknown
  elif [[ $val == *ed25519* ]]; then
    printf '%s\n' ed25519
  elif [[ $val == *rsa* ]]; then
    printf '%s\n' rsa
  else
    printf '%s\n' unknown
  fi
}

list_ssh_keys() {
  local keys_output
  if ! keys_output=$(op item list --categories="SSH Key" --format=json 2>/dev/null); then
    print_error "Failed to list SSH keys from 1Password"
    return 1
  fi

  # Parse JSON to get key names
  local key_names=()
  while IFS= read -r line; do
    [[ -n $line ]] && key_names+=("$line")
  done < <(echo "$keys_output" | jq -r '.[].title' 2>/dev/null || echo "")

  if [[ ${#key_names[@]} -eq 0 ]]; then
    print_error "No SSH keys found in 1Password"
    print_status "Create SSH keys in 1Password:"
    print_status "1. Open 1Password app"
    print_status "2. Click '+' â†’ 'SSH Key'"
    print_status "3. Either 'Import Existing' or 'Generate New'"
    return 1
  fi

  echo "${key_names[@]}"
}

download_ssh_key() {
  local key_name="$1"
  local key_path="$2"
  local key_type="$3" # "private" or "public"

  print_status "Downloading $key_type key: $key_name"

  # Download key directly
  if op item get "$key_name" --field "$key_type key" >"$key_path" 2>/dev/null; then
    # Set appropriate permissions
    if [[ $key_type == "private" ]]; then
      chmod 600 "$key_path"
    else
      chmod 644 "$key_path"
    fi
    print_status "âœ“ $key_type key saved: $key_path"
    return 0
  else
    print_error "âœ— Failed to download $key_type key: $key_name"
    rm -f "$key_path" # Clean up on failure
    return 1
  fi
}

download_work_ssh_config() {
  print_header "Checking for Work SSH Config"

  # Check if work SSH config exists in 1Password
  if ! op item get "$WORK_CONFIG_NAME" >/dev/null 2>&1; then
    print_warning "Work SSH config '$WORK_CONFIG_NAME' not found in 1Password"
    print_status "Skipping work SSH config setup"
    print_status ""
    print_status "To store your work SSH config in 1Password:"
    print_status "1. Open 1Password app"
    print_status "2. Click '+' â†’ 'Secure Note'"
    print_status "3. Title: '$WORK_CONFIG_NAME'"
    print_status "4. Paste your work SSH config in the notes field"
    print_status "5. Save"
    return 0
  fi

  print_status "Found work SSH config: $WORK_CONFIG_NAME"

  # Download the config content
  if op item get "$WORK_CONFIG_NAME" --field notesPlain >"$WORK_CONFIG_PATH" 2>/dev/null; then
    chmod 644 "$WORK_CONFIG_PATH"
    print_status "âœ“ Work SSH config saved: $WORK_CONFIG_PATH"

    # Validate it looks like SSH config
    if grep -q "Host\|HostName\|User\|IdentityFile" "$WORK_CONFIG_PATH" 2>/dev/null; then
      print_status "âœ“ Work SSH config appears valid"
    else
      print_warning "Work SSH config doesn't look like SSH configuration"
      print_status "Please verify the content in 1Password"
    fi

    return 0
  else
    print_error "âœ— Failed to download work SSH config"
    rm -f "$WORK_CONFIG_PATH"
    return 1
  fi
}

process_ssh_keys() {
  local keys=("$@")
  local success_count=0
  local failed_keys=()

  print_header "Processing SSH Keys"

  for key_name in "${keys[@]}"; do
    print_status "Processing: $key_name"

    # Normalize key name for filenames
    local safe_name
    safe_name=$(echo "$key_name" | tr ' ' '_' | tr -cd '[:alnum:]._-')

    # Determine desired filename prefix from 1Password metadata
    local key_type prefix
    key_type=$(get_key_type "$key_name" 2>/dev/null || echo unknown)
    case "$key_type" in
      ed25519) prefix="id_ed25519" ;;
      rsa) prefix="id_rsa" ;;
      *) prefix="id_key" ;;
    esac

    local private_path="$SSH_DIR/${prefix}_${safe_name}"
    local public_path="$private_path.pub"

    # Download private and public keys
    local private_ok=false
    local public_ok=false

    if download_ssh_key "$key_name" "$private_path" "private"; then
      private_ok=true
    fi

    if download_ssh_key "$key_name" "$public_path" "public"; then
      public_ok=true
    fi

    # Track results
    if [[ $private_ok == true && $public_ok == true ]]; then
      chmod 600 "$private_path" 2>/dev/null || true
      chmod 644 "$public_path" 2>/dev/null || true
      ((success_count++))
      print_status "âœ“ Successfully processed: $key_name -> $(basename "$private_path")"
    else
      rm -f "$private_path" "$public_path"
      failed_keys+=("$key_name")
      print_warning "âœ— Failed to process: $key_name"
    fi

    echo "" # Add spacing between keys
  done

  # Return results via global variables (bash limitation workaround)
  PROCESSED_COUNT=$success_count
  FAILED_KEYS=("${failed_keys[@]}")
}

link_default_key() {
  local title="$1"
  [[ -z $title ]] && return 0

  local safe_name
  safe_name=$(echo "$title" | tr ' ' '_' | tr -cd '[:alnum:]._-')

  local candidate
  for candidate in "id_rsa_${safe_name}" "id_ed25519_${safe_name}" "id_key_${safe_name}"; do
    if [[ -f "$SSH_DIR/$candidate" ]]; then
      local priv="$SSH_DIR/$candidate"
      local pub="$priv.pub"

      if [[ -e "$SSH_DIR/id_rsa" || -e "$SSH_DIR/id_rsa.pub" ]]; then
        print_warning "id_rsa or id_rsa.pub already exists; skipping default key link"
        return 0
      fi

      ln -sf "$priv" "$SSH_DIR/id_rsa"
      [[ -f $pub ]] && ln -sf "$pub" "$SSH_DIR/id_rsa.pub"
      print_status "âœ“ Set default key: id_rsa -> $(basename "$priv")"
      return 0
    fi
  done

  print_warning "Default key '$title' not found among processed keys"
  return 0
}

show_summary() {
  local total_keys=$1
  local success_count=$2
  shift 2
  local failed_keys=("$@")

  print_header "Summary"

  # SSH Keys Summary
  if [[ $success_count -eq $total_keys ]]; then
    print_status "ðŸŽ‰ All $total_keys SSH key(s) processed successfully!"
  else
    print_status "Processed $success_count out of $total_keys SSH key(s)"

    if [[ ${#failed_keys[@]} -gt 0 ]]; then
      print_warning "Failed keys:"
      for key in "${failed_keys[@]}"; do
        print_warning "  â€¢ $key"
      done
    fi
  fi

  # Work Config Summary
  if [[ -f $WORK_CONFIG_PATH ]]; then
    print_status "âœ“ Work SSH config installed: $WORK_CONFIG_PATH"
  else
    print_status "â—‹ No work SSH config (optional)"
  fi

  echo ""
  print_status "SSH setup complete! Files created in $SSH_DIR:"

  # Show downloaded files
  find "$SSH_DIR" -maxdepth 1 \( -name "id_rsa*" -o -name "id_ed25519*" -o -name "config.work" \) | sort | while read -r file; do
    if [[ -f $file ]]; then
      local perms basename_file
      perms=$(stat -f "%Mp%Lp" "$file" 2>/dev/null || stat -c "%a" "$file" 2>/dev/null || echo "???")
      basename_file=$(basename "$file")
      print_status "  $basename_file ($perms)"
    fi
  done

  echo ""
  print_status "Your SSH and Git configurations (from dotfiles) will handle the rest!"
  print_status "Test with: ssh -T git@github.com"
}

show_usage() {
  echo "Usage: $0 [OPTIONS] [KEY_NAME...]"
  echo ""
  echo "Download SSH keys and work config from 1Password to ~/.ssh/"
  echo ""
  echo "OPTIONS:"
  echo "  --work-config NAME    Name of work SSH config in 1Password"
  echo "                        (default: 'SSH Work Config')"
  echo "  --default-key NAME    Title of the key to link as ~/.ssh/id_rsa"
  echo "  -h, --help           Show this help message"
  echo ""
  echo "ARGUMENTS:"
  echo "  KEY_NAME             Specific SSH key name(s) to download"
  echo "                       If not provided, downloads all available keys"
  echo ""
  echo "EXAMPLES:"
  echo "  $0                                    # Download all keys + work config"
  echo "  $0 'Git Signing Key'                 # Download specific key + work config"
  echo "  $0 --work-config 'My Work SSH'       # Use custom work config name"
  echo "  $0 --default-key 'Primary Key'       # Link 'Primary Key' as id_rsa"
  echo ""
  echo "1PASSWORD SETUP:"
  echo "  SSH Keys: 1Password app â†’ + â†’ SSH Key â†’ Import/Generate"
  echo "  Work Config: 1Password app â†’ + â†’ Secure Note â†’ Title: 'SSH Work Config'"
  echo ""
  echo "PREREQUISITES:"
  echo "  â€¢ 1Password CLI (op) installed and signed in"
  echo "  â€¢ SSH keys stored in 1Password"
  echo "  â€¢ Dotfiles repo stowed (for main SSH config)"
}

main() {
  # Parse command line arguments
  local keys_to_process=()

  while [[ $# -gt 0 ]]; do
    case $1 in
      --work-config)
        WORK_CONFIG_NAME="$2"
        shift 2
        ;;
      --default-key)
        DEFAULT_KEY_NAME="$2"
        shift 2
        ;;
      -h | --help)
        show_usage
        exit 0
        ;;
      -*)
        print_error "Unknown option: $1"
        show_usage
        exit 1
        ;;
      *)
        keys_to_process+=("$1")
        shift
        ;;
    esac
  done

  print_header "1Password SSH Setup"
  echo ""

  # Check prerequisites
  if ! check_prerequisites; then
    exit 1
  fi

  # Ensure ~/.ssh exists with secure permissions
  ensure_ssh_dir

  # If no default specified, pick one based on host name
  if [[ -z $DEFAULT_KEY_NAME ]]; then
    local host_name
    host_name=$(scutil --get ComputerName 2>/dev/null || hostname 2>/dev/null || uname -n 2>/dev/null || echo "")
    host_name=$(printf '%s' "$host_name" | tr '[:upper:]' '[:lower:]')
    if [[ $host_name == *navi* ]]; then
      DEFAULT_KEY_NAME="gh_navi"
    else
      DEFAULT_KEY_NAME="gh_neptr"
    fi
    print_status "Auto-selected default key: $DEFAULT_KEY_NAME (host: $host_name)"
  fi

  # Determine which SSH keys to process
  if [[ ${#keys_to_process[@]} -eq 0 ]]; then
    # Download all available keys
    print_header "Available SSH Keys in 1Password"

    local available_keys
    if ! available_keys=$(list_ssh_keys); then
      exit 1
    fi

    # Convert to array
    read -ra keys_to_process <<<"$available_keys"

    if [[ ${#keys_to_process[@]} -eq 0 ]]; then
      print_error "No SSH keys available"
      exit 1
    fi

    print_status "Found ${#keys_to_process[@]} SSH key(s):"
    for i in "${!keys_to_process[@]}"; do
      echo "  $((i + 1)). ${keys_to_process[i]}"
    done
    echo ""
    print_status "Will download all ${#keys_to_process[@]} key(s)"
  else
    # Use provided key names
    print_status "Will download ${#keys_to_process[@]} specified key(s)"
  fi

  echo ""

  # Process SSH keys
  process_ssh_keys "${keys_to_process[@]}"

  # Link default key as id_rsa if requested
  if [[ -n $DEFAULT_KEY_NAME ]]; then
    link_default_key "$DEFAULT_KEY_NAME"
  fi

  # Download work SSH config (optional)
  download_work_ssh_config

  # Show summary
  show_summary "${#keys_to_process[@]}" "$PROCESSED_COUNT" "${FAILED_KEYS[@]}"
}

# Run main function if script is executed directly
if [[ ${BASH_SOURCE[0]} == "${0}" ]]; then
  main "$@"
fi
