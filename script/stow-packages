#!/usr/bin/env bash

set -e

# Fix locale issues (common in Codespaces) to silence perl warnings from stow
export LC_ALL=C
export LANG=C

# Source shared helpers
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=script/common.sh
. "$script_dir/common.sh"

# Initialize homebrew environment to ensure stow is available
init_homebrew() {
  if command -v brew >/dev/null 2>&1; then
    return 0
  fi

  print_status "Initializing Homebrew environment..."

  if is_macos; then
    if [[ -x "/opt/homebrew/bin/brew" ]]; then
      # macOS Apple Silicon
      eval "$(/opt/homebrew/bin/brew shellenv)"
    elif [[ -x "/usr/local/bin/brew" ]]; then
      # macOS Intel
      eval "$(/usr/local/bin/brew shellenv)"
    fi
  else
    # Linux
    if [[ -x "/home/linuxbrew/.linuxbrew/bin/brew" ]]; then
      eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
    fi
  fi

  if ! command -v brew >/dev/null 2>&1; then
    print_error "Homebrew not found. Please install it first by running ./script/setup"
    exit 1
  fi
}

# Default packages to stow
# Format: "package_name" for top-level dirs, or "parent:subdir" for nested dirs
DEFAULT_PACKAGES=(
  ".config:zsh"
  ".config:nvim"
)

# Backup conflicting files for a specific package or subdirectory
backup_conflicting_files() {
  local package="$1"
  local subdir="${2:-}"
  local backup_dir
  backup_dir="$HOME/.dotfiles_backup_$(date +%Y%m%d_%H%M%S)"
  local conflicts_found=false

  local display_name="$package"
  [[ -n $subdir ]] && display_name="$package/$subdir"

  print_status "Checking for conflicts with $display_name..."

  # Check what files would be created by stow
  local stow_output
  if [[ -n $subdir ]]; then
    stow_output=$(stow --simulate --no --verbose=2 --target="$HOME/$package" --dir=. "$subdir" 2>&1 || true)
  else
    stow_output=$(stow --simulate --no --verbose=2 --target="$HOME" "$package" 2>&1 || true)
  fi

  if echo "$stow_output" | grep -qi "conflict"; then
    print_warning "Found conflicts with $display_name"

    # Extract conflicting files from stow output
    local conflicting_files
    conflicting_files=$(echo "$stow_output" | grep -i "existing target" | sed 's/.*existing target is //' | sed 's/ .*//')

    for target_file in $conflicting_files; do
      local target_path
      if [[ -n $subdir ]]; then
        target_path="$HOME/$package/$target_file"
      else
        target_path="$HOME/$target_file"
      fi

      if [[ -e $target_path || -L $target_path ]]; then
        if ! $conflicts_found; then
          conflicts_found=true
          mkdir -p "$backup_dir"
          print_status "Created backup directory: $backup_dir"
        fi

        print_status "Backing up existing $target_file..."
        # Create parent directories in backup if needed
        local parent_dir
        parent_dir=$(dirname "$backup_dir/$target_file")
        mkdir -p "$parent_dir"

        mv "$target_path" "$backup_dir/$target_file"
        print_status "âœ“ Moved $target_file to backup"
      fi
    done

    if $conflicts_found; then
      print_status "âœ“ Conflicting files backed up to: $backup_dir"
    fi
  else
    print_status "âœ“ No conflicts found for $display_name"
  fi
}

# Stow a specific package or package:subdir
stow_package() {
  local input="$1"
  local package subdir
  local dotfiles_dir
  dotfiles_dir="$(cd "$script_dir/.." && pwd)"

  # Parse input - check if it contains a colon (parent:subdir format)
  if [[ $input == *":"* ]]; then
    package="${input%%:*}"
    subdir="${input#*:}"
  else
    package="$input"
    subdir=""
  fi

  # Change to dotfiles directory
  cd "$dotfiles_dir"

  # Verify package exists
  if [[ ! -e $package ]]; then
    print_error "Package not found: $package"
    return 1
  fi

  # If stowing a subdirectory, verify it exists
  if [[ -n $subdir ]]; then
    if [[ ! -e "$package/$subdir" ]]; then
      print_error "Subdirectory not found: $package/$subdir"
      return 1
    fi

    local display_name="$package/$subdir"
    print_status "Stowing $display_name..."

    # Ensure target parent directory exists
    mkdir -p "$HOME/$package"

    # Change to parent directory for stowing subdirectory
    cd "$package"

    # Check for conflicts
    if stow --simulate --no --verbose=2 --target="$HOME/$package" "$subdir" 2>&1 | grep -qi "conflict"; then
      if is_non_interactive; then
        print_status "Non-interactive mode: automatically backing up conflicting files"
        cd "$dotfiles_dir"
        backup_conflicting_files "$package" "$subdir"
        cd "$package"
      else
        echo ""
        if confirm "Package $display_name has conflicts. Backup existing files and continue?" y; then
          cd "$dotfiles_dir"
          backup_conflicting_files "$package" "$subdir"
          cd "$package"
        else
          print_warning "Skipping $display_name"
          return 0
        fi
      fi
    fi

    # Run stow for subdirectory
    if stow --target="$HOME/$package" "$subdir"; then
      print_status "âœ“ Successfully stowed $display_name"
    else
      print_error "Failed to stow $display_name"
      return 1
    fi
  else
    # Stowing a top-level package
    print_status "Stowing $package..."

    # Check for conflicts
    if stow --simulate --no --verbose=2 --target="$HOME" "$package" 2>&1 | grep -qi "conflict"; then
      if is_non_interactive; then
        print_status "Non-interactive mode: automatically backing up conflicting files"
        backup_conflicting_files "$package"
      else
        echo ""
        if confirm "Package $package has conflicts. Backup existing files and continue?" y; then
          backup_conflicting_files "$package"
        else
          print_warning "Skipping $package"
          return 0
        fi
      fi
    fi

    # Run stow
    if stow --target="$HOME" "$package"; then
      print_status "âœ“ Successfully stowed $package"
    else
      print_error "Failed to stow $package"
      return 1
    fi
  fi
}

# Show usage information
usage() {
  cat <<EOF
Usage: $(basename "$0") [PACKAGE...]

Stow specific dotfile packages to your home directory.

If no packages are specified, the following default packages will be stowed:
$(printf '  - %s\n' "${DEFAULT_PACKAGES[@]}")

Package Format:
  - For top-level directories: package_name (e.g., .zshrc)
  - For subdirectories: parent:subdir (e.g., .config:zsh)

Examples:
  $(basename "$0")                    # Stow default packages (zsh and nvim)
  $(basename "$0") .config:zsh        # Stow only zsh config from .config
  $(basename "$0") .config:nvim .config:zsh  # Stow multiple subdirectories

Note: This script loads Homebrew into the environment to ensure stow is available.
EOF
}

# Main function
main() {
  print_header "Selective Dotfiles Stowing"

  # Initialize homebrew to get stow
  init_homebrew

  # Check if stow is available
  if ! command -v stow >/dev/null 2>&1; then
    print_error "stow not found. Please install it first by running ./script/setup"
    exit 1
  fi

  # Determine which packages to stow
  local packages=()
  if [[ $# -eq 0 ]]; then
    # No arguments, use defaults
    packages=("${DEFAULT_PACKAGES[@]}")
    print_status "No packages specified, using defaults: ${packages[*]}"
  else
    # Use provided arguments
    packages=("$@")
  fi

  # Stow each package
  local failed=0
  for package in "${packages[@]}"; do
    if ! stow_package "$package"; then
      ((failed++))
    fi
  done

  echo ""
  if [[ $failed -eq 0 ]]; then
    print_status "ðŸŽ‰ All packages successfully stowed!"
  else
    print_warning "$failed package(s) failed to stow"
    exit 1
  fi
}

# Show usage if --help or -h is passed
if [[ $# -eq 1 && ($1 == "--help" || $1 == "-h") ]]; then
  usage
  exit 0
fi

# Run main function
main "$@"
